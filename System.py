import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
from matplotlib.animation import FuncAnimation
from Body import Body
from math import floor, log

class System:
    def __init__(self, bodies):
        self.bodies = bodies
        self.nbody = len(self.bodies)
        self.dimension = self.bodies[0].dimension

    def simulate(self, tf, dt):
        t_array = np.arange(0, tf, dt)
        position_history = np.zeros((self.nbody, self.dimension,
                                     floor(tf / dt)))
        for i in range(len(t_array)):
            t = t_array[i]
            for body in range(self.nbody):
                position_history[body,:,i] = self.bodies[body].position
            self.time_step(dt)
        # self.stationary_plot(position_history)
        self.animation(position_history, tf, dt)

    def time_step(self, dt):
        # Create arrays to store update vectors for position, velocity,
        # and acceleration.
        acc_update = np.zeros((self.nbody, self.dimension))
        vel_update = np.zeros((self.nbody, self.dimension))
        pos_update = np.zeros((self.nbody, self.dimension))

        # Iterate over every body, computing the total acceleration
        # vector generated by the aggregate force of the other bodies on
        # it. Store the vector to update that body with so we can update
        # all bodies simultaneously.
        for i in range(len(self.bodies)):
            body = self.bodies[i]
            other_bodies = self.bodies.copy()
            other_bodies.remove(body)
            for other in other_bodies:
                acc_update[i] += (body.calculate_acceleration(other) 
                                 * body.calculate_unit_direction(other))
            vel_update[i] = body.calculate_velocity(acc_update[i], dt)
            pos_update[i] = body.calculate_movement(vel_update[i], dt)

        # Update all bodies with respective new position / velocity
        # vectors.
        for i in range(len(self.bodies)):
            body = self.bodies[i]
            body.position = pos_update[i]
            body.velocity = vel_update[i]

    def stationary_plot(self, position_history):
        plt.figure()
        if self.dimension == 2:
            for body in range(self.nbody):
                plt.plot(position_history[body,0], position_history[body,1])
        elif self.dimension == 3:
            ax = plt.axes(projection='3d')
            for body in range(self.nbody):
                ax.plot3D(position_history[body,0], position_history[body,1],
                          position_history[body,2])
        plt.show()

    def animation(self, position_history, tf, dt):
        fig, ax = plt.subplots()
        xdata = position_history[:,0]
        ydata = position_history[:,1]

        line1, = plt.plot([], [], 'ro', label = self.bodies[0].id)
        line2, = plt.plot([], [], 'bo', label = self.bodies[1].id)
        line3, = plt.plot([], [], 'go', label = self.bodies[2].id)

        xlim = np.amax(xdata)
        ylim = np.amax(ydata)
        def init():
            ax.set_xlim(-xlim * 1.15, xlim * 1.15)
            ax.set_ylim(-ylim * 1.15, ylim * 1.15)
            return line1, line2, line3,

        def update(frame):
            line1.set_data(xdata[0,frame], ydata[0,frame])
            line2.set_data(xdata[1,frame], ydata[1,frame])
            line3.set_data(xdata[2,frame], ydata[2,frame])
            return line1, line2, line3

        interval = dt / 10
        ani = FuncAnimation(fig, update, init_func = init, blit = True,
                            interval = interval, frames = 3000)
        ani.save('output/3body_animation.mp4', extra_args=['-vcodec', 'libx264'])
        plt.legend()
        plt.show()